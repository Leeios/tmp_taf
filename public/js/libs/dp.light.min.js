(sand.define("DataPackage/Collection", [
  "core/Array/*",
  "core/hardClone",
  "core/isArray",
  "core/Array/exceptFn",
  "Seed",
  "DataPackage/Store",
  "core/hardCloneProperties",
  "core/protos/string",
  'core/Function/curry'
  ], function(r) {

  /**
   * IMPORTANT NOTE : as a convention, we consider that every id < 0 is a clientId,
   * when you insert a new model in the collection, without specifying an id, a new one (uniq to the collection) will be generated
   *
   * NOTE : we allow the "dot notation", for insertion and edition, for example :
   * model = this.insert({
   *  someRandom : "input",
   *  "some.tree.path" : "value"
   * });
   * model.some // => { tree : { path : "value" } }
   * model.edit({ "some.tree.path2" : "anotherValue" });
   * model.some // => { tree : { path : "value", path2 : "anotherValue" } }
   */


  var hardClone = r.hardClone,
    isArray = r.isArray,
    hardCloneProperties = r.hardCloneProperties,
    Store = r.Store,
    d = this.debug;

  var Collection = r.Seed.extend({

    _rdy : function() {}, // to override

    '-init' : function(o) {
      this._a = o.app;
    },

    '+init' : function(o) {

      //--- Base
      this._dp = o.dp;
      this._raw = (o.raw||[]).slice();
      this._model = o.model;
      this.name = this._model.prototype.lowerName+'s';

      //--- Versionning
      this.backup = {};
      this.stash = [];
      this.cursor = 0;
      this.backups = [];
      this.stashes = [];
      this.antiStashes = [];
      //--- Id Sync with server
      this.clientToServerIds = {};

      //--- Id generation
      this._minId = 0;

      //--- We build the association configuration of the model
      this.assos = {};
      this._isKey = {};

      //--- We wait that the dp is ready before setting up the associations, to avoid unecessary tambouille
      this._dp.whenReady(function() {
        var asso, j, k, keyName, label, mirrorLabel, ownedColl;
        for (var i = this._model.prototype.associations.length; i--; ) {
          asso = this._model.prototype.associations[i];
          for (j in asso) {
            if (asso.hasOwnProperty(j)) {
              if (j === "hasMany" || j === "belongsTo" || j === "belongsToMany" || j === "hasOne") { // association
                ownedColl = this._dp[(asso[j]+(j === "belongsTo" || j === "hasOne" ? "s" : "")).uncapitalize()];

                mirrorLabel = asso.mirrorLabel;

                keyName = asso.keyName;
                label = asso.label;

                var plural = false;
                if (
                    (j === "hasMany" && asso.mirror === "belongsToMany") // HABTM
                    || (j === "belongsTo" && asso.mirror === "hasMany")
                    || (j === "belongsToMany")
                ) plural = true;

                if (typeof(mirrorLabel) === "undefined") mirrorLabel = this._model.prototype.lowerName+(plural ? "s" : "");

                if (typeof(label) === "undefined") {
                  if (j === "hasMany" || j === "belongsToMany") label = asso[j];
                  else label = ownedColl._model.prototype.lowerName;
                }

                if (typeof(keyName) === "undefined") {
                  if (j === "hasMany") {
                    keyName = this._model.prototype.lowerName+(plural ? "_ids" : "_id");
                  }
                  else if (j === "hasOne") {
                    keyName = this._model.prototype.lowerName+"_id";
                  }
                  else if (j === "belongsToMany") {
                    keyName = asso[j].singularize().uncapitalize()+"_ids";
                  }
                  else if (j === "belongsTo") {
                    keyName = asso[j].uncapitalize()+"_id";
                  }
                }

                var constructor;
                if (j === "hasMany" && asso.mirror === "belongsToMany") constructor = "HasManyBTM";
                else if (j === "belongsTo" && asso.mirror === "hasOne") constructor = "BelongsToHO";
                else constructor = j.capitalize();

                this.assos[label] = {
                  label : label,
                  constructor : constructor,
                  keyName : keyName,
                  collection : ownedColl,
                  mirrorLabel : mirrorLabel,
                  HABTM : asso.HABTM
                };

                if (j === "belongsTo" || j === "belongsToMany") this._isKey[keyName] = this.assos[label];
              }
            }
          }
        }

        for (k = this.all.length; k--; ) {
          this.all[k].associate({ assos : this.assos, weak : true, collection : this });
        }

        this._rdy();

      }.bind(this));
      //---

      this._instances = {};
      this.all = [];
      for (var i = -1, n = this._raw.length; ++i < n; ) this._instanciate(i);
    },

    insertOrGet : function(e) {
      var alreadyIn;
      for (var i in e) {
        if (e.hasOwnProperty(i)) {
          if (this._model.prototype.uniqs.has(i)) {
            if (alreadyIn = this.last(function(m) {
              return m[i] === e[i];
            })) {
              return alreadyIn;
            }
          }
        }
      }
      return (this.insert(e));
    },

    allExcept : function(e, f, o) {
      if (typeof(f) === "string") {
        for (var i = this.all.length; i--; ) {
          if (this.all[i] !== e) {
            this.all[i][f](o);
          }
        }
      }
    },

    /**
     * Interface
     */

    sync : function() {

    },

    fixState : function() { // this takes all the pending client operations and merges them into one object
      this.saveState();
      var tmp = this.stashes[--this.cursor], i, j, stash;
      for (i = this.cursor; i--; ) {
        stash = this.stashes[i];
        for(j in stash) {
          if (stash.hasOwnProperty(j)) {
            if (tmp[j] && tmp[j].type !== 'remove') { // remove overrides all
              if (tmp[j].type === 'edit' && stash[j].type === 'edit') {
                tmp[j].input.smoothMerge(stash[j].input);
              }
              else { // edit && insert
                tmp[j].type = 'insert';
                tmp[j].input.smoothMerge(stash[j].input);
              }
            }
            else {
              tmp[j] = stash[j];
            }
          }
        }
      }
      for (i in tmp) {
        if (tmp.hasOwnProperty(i) && tmp[i].input) {
          tmp[i].input = this._toObject(tmp[i].input);
        }
      }

      this.cursor = 0;
      this.splice();
      this.backup = {};
      this.stash = {};

      return (tmp);
    },
    /**
     * Usage :
     * this.insert({ someRandom : "input" });
     * this.fixState() =>
     * { -1 : {
     *  type : "insert",
     *  input : { someRandom : "input" }
     * }
     */


    toStash : function(action) {

      //Need comment, PIE->Sam isn't it dangerous ?
      if (this._dp.digesting) return;

      //var inp = hardClone(action.model._raw);
      //if (action.type !== "insert") delete(inp.id);

      this.stash.push({
        type : action.type,
        input : action.input,//inp,//hardClone(action.input||action.model._raw), // care editId ...
        id : action.model.id
      });

    },

    /**
     * Versionning
     */

    previousState : function() {
      this._dp.digesting = true;
      var stash = this.antiStashes[--this.cursor];
      for (var i in stash) {
        if (stash.hasOwnProperty(i)) {
          this[stash[i].type](stash[i].input,i);
        }
      }
      this._dp.digesting = false;
    },

    nextState : function() {
      this._dp.digesting = true;
      var stash = this.stashes[this.cursor];
      for (var i in stash) {
        if (stash.hasOwnProperty(i)) {
          this[stash[i].type](stash[i].input,i);
        }
      }
      this._dp.digesting = false;
      this.cursor++;
    },

    saveState : function() {
      //--- We build the antiStash
      var antiStash = {}, action;
      for (var i in this.stash) {
        if (this.stash.hasOwnProperty(i)) {
          action = this.stash[i];
          if (action.type === 'edit') {
            antiStash[i] = {type:'edit',id:i,input:this.backup[i]};
          }
          else if (action.type === 'insert') {
            antiStash[i] = {type:'remove',id:i};
          }
          else if (action.type === 'remove') {
            antiStash[i] = {type:'insert',input:this.backup[i]};
          }
        }
      }
      this.antiStashes[this.cursor] = antiStash;

      this.backups[this.cursor] = this.backup;
      this.stashes[this.cursor] = this.stash;
      this.stash = {};
      this.backup = {};

      this.cursor++;
    },

    rollback : function() {
      this.saveState();
      for (var i = this.cursor; i--; ) {
        this.previousState();
      }
      this.fixState(); // clears this
    },

    //---
    // Merges 2 actions
    // NOTE :
    //  insert + edit =>
    //    stash : insert augmented with edit input
    //    backup : void
    //  edit + edit =>
    //    stash : edit augmented with edit input
    //    backup : i in input, if !backup[i], clone model[i]
    //  edit + remove => remove
    //    stash : remove
    //    backup : i in input, if !backup[i], clone model[i]
    //  insert + remove => remove
    //    stash : void
    //    backup : void
    //
    //
    // NOTE : there are still bugs with this atm, TODO : debug ...
    //-
    mergeActions : function(a1, a2) { // merges 2 actions
      if (a2.type === 'remove' && a1.inserted === true) {
        delete this.stash[a2.model.id];
        delete this.backup[a2.model.id];
      }
      else if (a2.type === 'remove') { // edit then remove
        a1.type = 'remove';

        this.smoothMergeClone(this.backup[a2.model.id],a2.model._raw);
        //this.backup[a2.model.id].smoothMergeClone(a2.model._raw);


        delete a1.input;
      }
      else if (a2.type === 'edit') {
        // insert + edit = insert
        this.mergeClone(a1.input, a2.input);
        if (a1.type === 'edit') // edit + edit {
          { this.smoothMergeClone(this.backup[a2.model.id], hardCloneProperties(a2.input, a2.model)); }
          //this.backup[a2.model.id].smoothMergeClone(a2.input);
        //else this.backup[a2.model.id] = (a2.input); // insert + edit
      }
    },

    mergeClone : function(a, b) {
      for (var i in b) {
        if (b.hasOwnProperty(i)) {
          a[i] = b[i];
        }
      }
    },

    smoothMergeClone : function(a, b) {
      for (var i in b) {
        if (b.hasOwnProperty(i)) {
          if (typeof(a[i]) === "undefined") {
            a[i] = hardClone(b[i]);
          }
        }
      }
    },

    /**
     * Basics
     */

    _instanciate : function(rawIndex, opt) {
      this.all.push(this._instances[this._raw[rawIndex].id] = new ((opt && opt.model && Store[opt.model]) || this._model)({ dp : this._dp, raw : this._raw[rawIndex], app : this._a, collection : this }));
      //this._instances[this._raw[rawIndex][0]].associate({ collection : this, assos : this.assos});
      return (this._instances[this._raw[rawIndex].id]);
    },

    generateId : function() { // generates a new id, not already used (by this collection) and < 0
      return this._dp.namespace + --this._minId;
    },

    insertMany : function(o, opt) {
      var mdls = [];
      for (var i = o.length; i--; ) mdls.push(this.insert(o[i], {dontFire:true}));
      this.fire("insert", mdls, opt);
      return mdls;
    },

    insert : function(o, opt) { // inserts a new model in this collection, and instanciates it
      //console.log(">>>> insert", o);

      if (this._a.dp.logs.length > 199) this._a.dp.logs.shift();
      this._a.dp.logs.push({
        type : 'insert',
        name : this.name,
        input : o,
        args : arguments
      });

      if (!o.id) // no id
        o.id = this.generateId();

      if (!opt || !opt.dontFormat) {
        o = this._format(o);
      }
      //o = hardClone(o);

      this._instanciate(this._raw.push(o) - 1, opt);
      (!opt || !opt.dontPushStash) && this.toStash({type:'insert',model:this._instances[o.id],input:o}); //MCB, this was right before the nxt line
      this._instances[o.id].associate({ assos : this.assos, collection : this });
      (!opt || !opt.dontFire) && this.fire("insert", [this._instances[o.id]], opt); // models, opts
      return (this._instances[o.id]);
    },

    //WCB pas de dontPushStash pour insert, dnow
    edit : function(input, m, opt) { // fromRemove is used to not fire when its edit keys of a removed item
      //console.log(">>>> edit", m, input);


      if (this._a.dp.logs.length > 199) this._a.dp.logs.shift();
      this._a.dp.logs.push({
        type : 'edit',
        name : this.name,
        input : input,
        args : arguments
      });

      var assos = [];
      for (var i in input) {
        if (input.hasOwnProperty(i))
          if (this._isKey[i]) {
            assos.push(i);
          }
      }

      var models = this._toMdls(m), j, resets = [], asso;
      for (i = models.length; i--; ) {

        if (!models[i]) {
          d.e&&console.log("[ERROR] edition of a non existing model, reinsert",models,i,m);
          this.insert(input);
        }

        else {

        var o = this._format(input, models[i]); // dot adding

        //hardfix -27000
        if (o['tm.rect']) {
          var fail = false;

          if (o['tm.rect'][0][1] < -1000000 || o['tm.rect'][0][1] > 1000000) {
            o['tm.rect'] = [[0, 0], o['tm.rect'][1]];
            fail = true;
          }

          if (o['tm.rect'][1][1] > 1000000) {
            o['tm.rect'] = [o['tm.rect'][0], [models[i].tm.rect[1][0], models[i].tm.rect[1][1]]];
            fail = true;
          }

          if (fail) {
            //console.log('fail', this._a.dp.logs.map(function(e) { return { type : e.type, name : e.name, input : e.input } }));
            $.ajax({
              type : 'POST',
              url : '/api/track/bug',
              data : {
                bug_id : '-27000',
                actions : JSON.stringify(this._a.dp.logs.map(function(e) { return { type : e.type, name : e.name, input : e.input } }))
              }
            });
          }
        }

        if (!models[i].removed) {



          models[i]._edit(o, opt); // this will fire onKeyChange and update associations if needed

          //MCB, it used to be above the previous line
          this.toStash({type:'edit',input:o,model:models[i]});

          for (j = assos.length; j--; ) {
            asso = models[i]["$"+this._isKey[assos[j]].label];
            if (typeof(opt) === "undefined" || typeof(opt.weak) === "undefined") {
              resets = resets.concat(asso.els.collect(function(e) { return e&&e["$"+asso._mirrorLabel] }));
            }
            if (typeof(opt) === "undefined" || typeof(opt.important) === "undefined") asso.onKeyChange();
            if (typeof(opt) === "undefined" || typeof(opt.weak) === "undefined") {
              resets = resets.concat(asso.els.collect(function(e) { return e&&e["$"+asso._mirrorLabel] }));
            }
          }
        }

        }
      }

      resets = resets.uniq();
      for (i = resets.length; i--; ) resets[i]&&resets[i].reset();

      (!opt || !opt.dontFire) && this.fire("edit", models, o, opt, input); // models, changes, options
      return [models, o, opt, input];
    },

    remove : function(o, oo) {
      if (this._a.dp.logs.length > 199) this._a.dp.logs.shift();

      this._a.dp.logs.push({
        type : 'remove',
        name : this.name,
        input : o,
        args : arguments
      });

      //console.log(">>>> remove", o);
      o = this._toMdls(o);
      var resets = [];
      for (var i = o.length; i--; ) {

        if (!o[i]) {
          console.log("!!!!!! remove of an non existin model, doing nothing");
        }
        else {

        if (!oo || !oo.dontPushStash) this.toStash({type:'remove',id:o[i].id,model:o[i]});

        for (var j = o[i]._assos.length; j--; ) {
          for (var k = o[i]._assos[j].els.length; k--; ) {
            o[i]._assos[j].els[k] && resets.push(o[i]._assos[j].els[k]["$"+o[i]._assos[j]._mirrorLabel])
          }
        }

        this.all.remove(o[i]);
        this._raw.remove(o[i]._raw);
        this._instances[o[i].id] = null;

        o[i]._remove();

        }
      }

      // at this point, resets contains all the assos that needs to remove o (o might be not included in asso elements)
      resets = resets.uniq().exceptFn(function(e) {
        return e.removed
      });


      for (i = resets.length; i--; ) {
        if (resets[i].foreign) {
          resets[i].remove(o, {weak:true});
        }
        else {
          resets[i].remove(o, {weak:true});
        }
      }

      this.fire("remove", o, oo); // models, options
    },

    //---
    // Usage :
    // this.find({ label : "text" });
    // this.find(function(e) { return e.label === "text" });
    //
    // IMPORTANT NOTE : this.find(1) === this.find(1)
    //-
    find : function(o) { // either an id (string or number), a function, or an object
      if (typeof(o) === "number" || typeof(o) === "string") {
        return this._instances[o] || null; // we return the model if it has already been instanciated, otherwise we try to find it
      }
      var f = this._toF(o), res = [];
      for (var i = this.all.length; i--; ){
        if (f(this.all[i])) res.push(this.all[i]);
      }
      return res;
    },

    last : function(o) { // like find, but only returns the first found occurence, so it's faster'
      var f = this._toF(o); // we get the find function
      for (var i = this.all.length; i--; ) {
        if (f(this.all[i])) {
          return (this.all[i]);
        }
      } return null;
    },

    /**
     * Formats the input to allow dot notation
     */

    _format : function(o, m) {
      var format = function(o, r, prefix) {
        if (!r) r = {};
        if (!prefix) prefix = '';
        for (var i in o) if (o.hasOwnProperty(i)) {
          if (
            o[i] && // not null
            typeof(o[i]) === 'object' &&
            !isArray(o[i])) {
            format(o[i], r, prefix + i + '.');
          }
          else {
            r[prefix + i] = o[i];
          }
        }
        return r;
      }
      return format(o);

      var r = {};
      for (var i in o) {
        if (o.hasOwnProperty(i)) {
          var sp = i.split(".");
          if (sp.length > 1) { // dot
            r[sp[0]] = hardClone(m[sp[0]])||{};
            var a = r[sp[0]];
            for (var j = 1, n = sp.length - 1; j < n; j++) {
              a = a[sp[j]]||(a[sp[j]]={});
            }

            a[sp[n]] = o[i];
          }
          else {
            r[i] = o[i];
          }
        }
      }
      return r;
    },

    splice : function() {
      this.stashes.splice(this.cursor, this.stashes.length - this.cursor);
      this.backups.splice(this.cursor, this.backups.length - this.cursor);
      this.antiStashes.splice(this.cursor, this.antiStashes.length - this.cursor);
    },

    /**
     * Input formating helpers
     */

    _toObject : function(raw) {
      if (isArray(raw)) {
        var o = {};
        for (var i = raw.length; i--; ) if (typeof(raw[i]) !== 'undefined') o[this._attrs[i]] = raw[i];
        return o;
      }
      return (raw);
    },

    _toArray : function(raw) {
      if (!isArray(raw)) { // object
        var arrayedRaw = [];
        for (var i in raw) {
          if (raw.hasOwnProperty(i)) {
            arrayedRaw[this._toAttrs[i]] = raw[i];
          }
        }
        raw = arrayedRaw;
      }
      return raw;
    },

    _toMdls : function(o) {
      var r;
      if (!isArray(o)) { // not array
        if (typeof(o) === "number" || typeof(o) === "string") // id
          return ([this.find(o)]);
        // else model
          return ([o]);
      }
      if (r = o.length) { // array not empty
        if (typeof(o[0]) === "number" || typeof(o[0]) === "string") { // array of ids
          var r = [];
          for (var i = o.length; i--; ) r.push(this.find(o[i]));
          return r;
        }
        // else models
          return o.slice();
      }
      return [];
    },

    _toF : function(o) {
      if (typeof(o) === "function") return (o);
      var self = this
      if (typeof(o) === "object") return (function(elt) {
        for (var i in o) {
          if (o.hasOwnProperty(i) && elt[i] !== o[i]) return false;
        }
        return true;
      });
      if (typeof(o) === "undefined") return (function() {return true});
    }

  });

  Collection.extend = function(o) {
    if (!o.name) {
      //todo ?
      o.name = "missings";
    }
    return (Store[o.name.capitalize()] = r.Seed.extend.call(Collection, o));
  };

  for (var i in Array.prototype) {
    if (Array.prototype.hasOwnProperty(i) && !Collection.prototype[i]) {
      Collection.prototype[i] = (function(i) { return function() {
        return Array.prototype[i].apply(this.all, arguments);
      } })(i);
    }
  }

  Collection.prototype.map = function() {
    return Array.prototype.map.apply(this.all, arguments);
  };

  return Collection;

}));
(sand.define("DataPackage/Controller", [
    "Seed",
    "core/extend",
    "core/isArray",
    "core/empty",
    "DataPackage/Store",
    "DataPackage/Model",
    "DataPackage/Collection"
  ],
  function(r) {

  var extend = r.extend,
    isArray = r.isArray,
    empty = r.empty,
    Store = r.Store,
    d = this.debug;

  var Main = r.Seed.extend({

    '+init' : function(o) {
      this.logs = [];

      // get a random namespace string in hexa
      this.namespace = Math.random().toString(36).slice(2);
      this.timestamp = o.timestamp;
      this.diff = {};
      this.collections = {};
      this._ready = false;
      this._waiting = [];
      this.buffer = [];
      if (o.data) {
        this.doImport(o.data);
        this.ready();
      }
    },

    cache : function() {
      for (var i in this.collections) {
        if (this.collections.hasOwnProperty(i)) {
          for (var j = this.collections[i].all.length; j--; ) {
            if (this.collections[i].all[j].cache) this.collections[i].all[j].cache();
            else break;
          }
        }
      }
    },

    doImport : function(o) {
      this.collections = this.collections || {};
      for (var i in o) if (o.hasOwnProperty(i)) {
        var name =  i.capitalize().substr(0, i.length - 1);
        this.collections[i] = this.buildCollection({
          builder : Store[i.capitalize()],
          model : Store[name] || this.makeModel({ name : name }),//(app.Models && app.Models[i.capitalize().singularize()]) || this.makeModel({ name : i.capitalize().substr(0, i.length - 1) }),
          raw : o[i],
          app : this._a
        });
        this.diff[i] = this.collections[i].stash;
      }
    },

    saveState : function() {
      for (var i in this.collections) if (this.collections.hasOwnProperty(i)) this.collections[i].saveState();
    },

    nextState : function() {
      for (var i in this.collections) if (this.collections.hasOwnProperty(i)) this.collections[i].nextState();
    },

    previousState : function() {
      for (var i in this.collections) if (this.collections.hasOwnProperty(i)) this.collections[i].previousState();
    },

    notChanged : function() { // returns true if the dp hasn't changed locally, used before unload atm
      for (var i in this.collections) {
        if (this.collections[i].cursor) return false;
        if (!empty(this.collections[i].stash)) return false;
      }
      return true;
    },

    /*diff : function() { // gets all the changes for each collections, see DP.Collection.fixState
      var diff = {};
      for (var i in this.collections) diff[i] = this.collections[i].fixState();

      this._lastdiff = diff;
      return diff;
    },*/

    //---
    // Really important function, bit complex also
    //
    // It takes all the changes of all the collections and puts them in a array of requests, formated so that a model requiring the
    // existence of another is put before the other
    // NOTE : Each request is then independent
    // NOTE : As a convention, a model that has a foreign key with a < 0 value is considered requiring the pointed model
    //  as another convention, someRandomKey_id, someRandomKey_ids are foreign keys
    //
    // EXAMPLE :
    // a insert { model : "Post", input : { text : "someText", "author_id" : -1 } }
    // will be considered requiring a { type : "insert", model : "Author", input : { id : -1 ... } }
    // so the formated request of {model:"Post",type:"insert",input:{"text":"someText",author_id:-1}}, {model:"Author",type:"insert",input:{id:-1}}
    // will look like : [[[{model:"Author",type:"insert",input:{id:-1}}, {model:"Post",type:"insert",input:{"text":"someText",author_id:-1}}]]]
    //
    // the return is an array of requests
    // a request is an array of level
    // the lvl 0 is the one that depends on no other action
    // lvl 1 depends on lvl 0, ...
    // so, it looks like
    // [ // array of requests
    //   [ // first request
    //     [ // first lvl
    //       {} // first action
    //     ],
    //     [ // second lvl
    //       {} // action requering the first action
    //     ]
    //   ], // end of request
    //   [ // second request, no action of this is dependend of the first one
    //     [
    //       {}
    //     ]
    //   ] // end of second request
    // ] // end of requests
    //-
    format : function(diff) {
      var coll,
        res = [],
        keys,
        j,
        placed = {},
        requests = {},
        count = -1,
        collections = this.collections,
        dp = this,

        getNumber = function(request) {
          if (typeof(requests[request]) !== "number") {
            return request;
          }
          return getNumber(requests[request]);
        },

        getRequest = function(request) {
            if (typeof(request) === "number") return (getRequest(requests[request]));
            return request
        },

        unite = function(reqs) {
          var res = [], ns = [], i, num;
          for (i = reqs.length; i--; ) {
            num = getNumber(reqs[i]);
            if (!ns.has(num)) {
              ns.push(num);
              res.push(reqs[i]);
            }
          }
          return res;
        },

        merge = function(reqs) {
          reqs = unite(reqs);
          var n = reqs.length, req;
          if (n > 1)
          {
              requests[++count] = []; // new request

              for ( ; n--; ) // for each request to merge
              {
                  req = getRequest(requests[reqs[n]]); // we get the request (reqs is an array of pointers)
                  for (var i = 0, l = req.length; i < l; i++) // for each lvl (l) of the request
                  {
                     requests[count][i] = (requests[count][i] || []).concat(req[i]) // we add it to our new request lvl
                     //requests[count][i] = ; // we stack each request of each lvl
                  }
                requests[reqs[n]] = count; // we point to the new request
              }
              return (count);
          }
          else {
            var c = getNumber(reqs[0]);
            return (c)
          }
      },

      getKeys = function(o, coll) {
        var res = {};
        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            if (o[i] && typeof(o[i]) === "object" && !isArray(o[i])) {
              extend(res, getKeys(o[i], coll));
            }
            else {
              if (i.search(/_id/) !== -1 || i.search(/_ids/) !== -1) {
                var collName = getCollName(i, coll);
                res[collName] = o[i];
              }
            }
          }
        }
        return res;
      },

      getCollName = function(i, coll) {
        if (collections[coll]._isKey[i]) return collections[coll]._isKey[i].collection.name;
        else {
          // tm.parent_id
          var sp = i.split("_");
          sp.splice(sp.length-1,1);
          sp = sp.join("_");

          // tm.parent
          sp = sp.split(".");
          return (sp.last()+"s")
        }
      },

      place = function(coll, id) {
        var toMerge, lvl = -1, collName, p, o = diff[coll][id];
        //console.log("placing ---> "+coll+id);
        if (!placed[coll+id]) { // this operation is not already in a request
          if (o.input) { // && (keys = o.input.keys)) // we must check if there is a - id, otherwise we can put the operation in a new request (lvl 0)
            var keys = getKeys(o.input, coll);
            toMerge = [];
            for (var i in keys) if (keys.hasOwnProperty(i)) {
              collName = i;
              //console.log(keys);
              // we get the collection from the key name, so we can find the needed operation
              if (keys[i] && isArray(keys[i])) { // array of ids
                j = keys[i].length;
                for ( ; j--; ) {
                  if (diff[collName] && diff[collName][keys[i][j]]) { // local model
                    p = place(collName, keys[i][j]);
                    toMerge.push(p.request);
                    if (p.lvl > lvl) lvl = p.lvl; // we store the maximum lvl
                  }
                }
              }
              else if (diff[collName] && diff[collName][keys[i]]) {
                p = place(collName, keys[i]);
                toMerge.push(p.request);
                if (p.lvl > lvl) lvl = p.lvl;
              }
            }
          }

          o.model = collections[coll]._model.prototype.name;
          o.id = id;

          if (!++lvl) { // new request (lvl = 0)
            requests[++count] = [[o]]; // new request
            placed[coll+id] = {
              request : count,
              lvl : lvl
            }
          }
          else {
            j = merge(toMerge.uniq());

            (requests[j][lvl] || (requests[j][lvl] = [])).push(o);
            placed[coll+id] = {
              request : j, // this will build the new request
              lvl : lvl
            }
          }
        }
        return (placed[coll+id]);
      }

      for (var i in diff) {
        for (j in diff[i]) {
          place(i, j);
        }
      }

      var res = [];
      for (var i in requests) {
        if (requests.hasOwnProperty(i)) {
          (typeof(requests[i]) !== "number") && res.push(requests[i]);
        }
      }

      this._lastres = res;
      return res;
    },

    makeModel : function(o){
      return (this[o.name] = r.Model.extend(o));
    },

    buildCollection : function(o) { // [{}, {}] ...
      var collName = o.model.prototype.lowerName+"s";
      return (this.collections[collName] = this[collName] = new (this.getBuilder(o))(extend(o, { dp : this })));
    },

    getBuilder: function(o){
      // problem here cause "DP-Collection" requires DP ...
      return (o.builder || r.Collection.extend(o))
    },

    whenReady : function(c) {
      if (this._ready !== false) {
        c();
      }
      else {
        this._waiting.push(c);
      }
    },

    make : function(o) {
      for (var i = o.length; i--; ) {
        this.makeModel({
          name : o[i][0],
          attrs : o[i][1],
          associations : o[i][2]
        });
        this.buildCollection({
          model : this[o[i][0]],
          raw : o[i][3]
        });
      }
      this.ready();
    },

    ready : function() {
      for (var i = this._waiting.length; i--; ) {
        this._waiting[i]();
      }
      this._waiting = [];
    },

    dump : function() {
      var res = {}
      for (var i in this.collections) {
        if (this.collections.hasOwnProperty(i)) {
          var coll = this.collections[i];
          res[coll.name] = []
          coll.all.each(function(e) {
            // res[coll.name].push(e._raw)
            // fix (bug on editId)
            var o = {};
            for (var i in e._raw) {
              if (e._raw.hasOwnProperty(i)) {
                o[i] = e.get(i);
              }
            }
            res[coll.name].push(o);

          });
        }
      }
      return res;
    },

    mergeClone : function(a, b) {
      for (var i in b) {
        if (b.hasOwnProperty(i)) {
          a[i] = b[i];
        }
      }
    },

    smoothMergeClone : function(a, b) {
      for (var i in b) {
        if (b.hasOwnProperty(i)) {
          if (typeof(a[i]) === "undefined") {
            a[i] = hardClone(b[i]);
          }
        }
      }
    },

    format2 : function(diff) {
      String.prototype.singularize = function() { //dirty
        return this.substr(0, this.length-1);
      };

      var friendly = {},

        mergeClone = function(a, b) {
          for (var i in b) {
            if (b.hasOwnProperty(i)) {
              a[i] = b[i];
            }
          }
        };

      for (var i in diff) if (diff.hasOwnProperty(i)) {
        friendly[i] = this.merge(diff[i], i);
      }

      return (this.format(friendly));
    },

    merge : function(diff, collName) {
      var o = {},
        modelName = collName.capitalize().singularize();
      for (var i = 0, n = diff.length; i < n; i++) {
        var action = diff[i];
        action.model = modelName;

        if (action.type === "insert") {
          o[action.id] = action;
        }
        else if (action.type === "edit") {
          if (o[action.id]) { // insert + edit = insert
            this.mergeClone(o[action.id].input, action.input);
          }
          else { // nothing + edit = edit
            o[action.id] = action;
          }
        }
        else { // remove
          if (o[action.id] && o[action.id].type === "insert") delete(o[action.id]);
          else {
            o[action.id] = action;
          }
        }
      }
      return o;
    }

  });

  return Main;

}));
sand.define('DataPackage/Model', [
  'core/String/capitalize',
  'core/String/uncapitalize',
  'core/extend',
  'Seed',
  'DataPackage/Store',
  'DataPackage/BelongsToHO',
  'DataPackage/BelongsToMany',
  'DataPackage/HasManyBTM',
  'DataPackage/HasOne',
  'DataPackage/HasMany',
  'DataPackage/BelongsTo',
  'core/clone'
], function(r) {

  var extend = r.extend;

  return r.Seed.extend({

    uniqs : ['id'],

    '-init' : function(o) {
      this._a = o.app;
      this._dp = o.dp;
      this._raw = o.raw;
    },

    '+init' : function(o) {
      o = o.raw;
      var s, j, n, attr;
      for (var i in o) if (o.hasOwnProperty(i)) {
        s = i.split('.'), n = s.length;
        if (n > 1) {
          attr = this[s[0]]||(this[s[0]] = {});
          for (j = 1; j < n - 1; j++) {
            attr = attr[s[j]]||(attr[s[j]] = {});
          }
          attr[s[n - 1]] = o[i];
        }
        else {
          this._raw[i] = o[i];
          this[i] = o[i];
        }
      }
      return;
      for (var i in o.raw) {
        if (o.raw.hasOwnProperty(i)) {
          this[i] = o.raw[i];
        }
      }
    },

    associate : function(o) { // creates the associations of the model
      this._assos = [];
      for (var i in o.assos) {
        if (o.assos.hasOwnProperty(i)) {
          this._assos.push(this['$'+o.assos[i].label] = new (r[o.assos[i].constructor])(extend(o.assos[i], { owner : this, weak : o.weak })));
        }
      }
      if (o.collection) this._collection = o.collection;
    },

    get : function(path) { // gets a tree attribute, useful when you're not sure wheter the full tree exists or not
      var path = path.split('.'), ret = this;
      for (var i = 0, n = path.length; i < n; i++) {
        if (typeof((ret = ret[path[i]])) === 'undefined') return null;
        if (i < n - 1 && !ret) return null;
      }
      return ret;
    },

    set : function(path, value) { // sets a tree attribute, same as above
      var path = path.split('.'), ret = this;
      for (var i = 0, n = path.length-1; i < n; i++) {
        ret = ret[path[i]];
      }
      return (ret[path[n]] = value);
    },

    edit : function(o, opt) {
      this._collection.edit(o, this, opt);
    },

    _edit : function(o, opt) { // fires 'editId' if you edit the id, used by associations to update the keys
      var s, j, n, attr;
      for (var i in o) if (o.hasOwnProperty(i)) {
        s = i.split('.'), n = s.length;
        if (n > 1) {
          attr = this[s[0]]||((this[s[0]] = {}));
          for (j = 1; j < n - 1; j++) {
            attr = attr[s[j]]||(attr[s[j]] = {});
          }
          attr[s[n - 1]] = o[i];
          //this._raw[s[0]] = this[s[0]]; WCB ?
          this._raw[i] = o[i];
        }
        else {
          this._raw[i] = o[i];
          this[i] = o[i];
        }
      }
      this.fire('edit', o, opt);
    },

    _remove : function() {
      this.removed = true;
      this.fire('remove');
    },

    remove : function(o) {
      this._collection.remove(this, o);
    },

    extend : function(o) {
      var M = r.Seed.extend.call(this, o),
        ret = this.prototype._extend(o, M);
      if (o.name) {
        r.Store[o.name.capitalize()] = ret;
      }
      return ret;
    },

    _extend : function(o, M) {
      if (o.name) M.prototype.lowerName = o.name.uncapitalize();
      if (typeof(M.prototype.associations) === 'undefined') M.prototype.associations = [];

      return M;
    }

  });

});
(sand.define('DataPackage/Store', function() { return {} })); // auto-define of sand doesn't work when it's added on-the-fly to the module required
(sand.define("DataPackage/Collection", [
  "core/Array/*",
  "core/hardClone",
  "core/isArray",
  "core/Array/exceptFn",
  "Seed",
  "DataPackage/Store",
  "core/hardCloneProperties",
  "core/protos/string",
  'core/Function/curry'
  ], function(r) {

  /**
   * IMPORTANT NOTE : as a convention, we consider that every id < 0 is a clientId,
   * when you insert a new model in the collection, without specifying an id, a new one (uniq to the collection) will be generated
   *
   * NOTE : we allow the "dot notation", for insertion and edition, for example :
   * model = this.insert({
   *  someRandom : "input",
   *  "some.tree.path" : "value"
   * });
   * model.some // => { tree : { path : "value" } }
   * model.edit({ "some.tree.path2" : "anotherValue" });
   * model.some // => { tree : { path : "value", path2 : "anotherValue" } }
   */


  var hardClone = r.hardClone,
    isArray = r.isArray,
    hardCloneProperties = r.hardCloneProperties,
    Store = r.Store,
    d = this.debug;

  var Collection = r.Seed.extend({

    _rdy : function() {}, // to override

    '-init' : function(o) {
      this._a = o.app;
    },

    '+init' : function(o) {

      //--- Base
      this._dp = o.dp;
      this._raw = (o.raw||[]).slice();
      this._model = o.model;
      this.name = this._model.prototype.lowerName+'s';

      //--- Versionning
      this.backup = {};
      this.stash = [];
      this.cursor = 0;
      this.backups = [];
      this.stashes = [];
      this.antiStashes = [];
      //--- Id Sync with server
      this.clientToServerIds = {};

      //--- Id generation
      this._minId = 0;

      //--- We build the association configuration of the model
      this.assos = {};
      this._isKey = {};

      //--- We wait that the dp is ready before setting up the associations, to avoid unecessary tambouille
      this._dp.whenReady(function() {
        var asso, j, k, keyName, label, mirrorLabel, ownedColl;
        for (var i = this._model.prototype.associations.length; i--; ) {
          asso = this._model.prototype.associations[i];
          for (j in asso) {
            if (asso.hasOwnProperty(j)) {
              if (j === "hasMany" || j === "belongsTo" || j === "belongsToMany" || j === "hasOne") { // association
                ownedColl = this._dp[(asso[j]+(j === "belongsTo" || j === "hasOne" ? "s" : "")).uncapitalize()];

                mirrorLabel = asso.mirrorLabel;

                keyName = asso.keyName;
                label = asso.label;

                var plural = false;
                if (
                    (j === "hasMany" && asso.mirror === "belongsToMany") // HABTM
                    || (j === "belongsTo" && asso.mirror === "hasMany")
                    || (j === "belongsToMany")
                ) plural = true;

                if (typeof(mirrorLabel) === "undefined") mirrorLabel = this._model.prototype.lowerName+(plural ? "s" : "");

                if (typeof(label) === "undefined") {
                  if (j === "hasMany" || j === "belongsToMany") label = asso[j];
                  else label = ownedColl._model.prototype.lowerName;
                }

                if (typeof(keyName) === "undefined") {
                  if (j === "hasMany") {
                    keyName = this._model.prototype.lowerName+(plural ? "_ids" : "_id");
                  }
                  else if (j === "hasOne") {
                    keyName = this._model.prototype.lowerName+"_id";
                  }
                  else if (j === "belongsToMany") {
                    keyName = asso[j].singularize().uncapitalize()+"_ids";
                  }
                  else if (j === "belongsTo") {
                    keyName = asso[j].uncapitalize()+"_id";
                  }
                }

                var constructor;
                if (j === "hasMany" && asso.mirror === "belongsToMany") constructor = "HasManyBTM";
                else if (j === "belongsTo" && asso.mirror === "hasOne") constructor = "BelongsToHO";
                else constructor = j.capitalize();

                this.assos[label] = {
                  label : label,
                  constructor : constructor,
                  keyName : keyName,
                  collection : ownedColl,
                  mirrorLabel : mirrorLabel,
                  HABTM : asso.HABTM
                };

                if (j === "belongsTo" || j === "belongsToMany") this._isKey[keyName] = this.assos[label];
              }
            }
          }
        }

        for (k = this.all.length; k--; ) {
          this.all[k].associate({ assos : this.assos, weak : true, collection : this });
        }

        this._rdy();

      }.bind(this));
      //---

      this._instances = {};
      this.all = [];
      for (var i = -1, n = this._raw.length; ++i < n; ) this._instanciate(i);
    },

    insertOrGet : function(e) {
      var alreadyIn;
      for (var i in e) {
        if (e.hasOwnProperty(i)) {
          if (this._model.prototype.uniqs.has(i)) {
            if (alreadyIn = this.last(function(m) {
              return m[i] === e[i];
            })) {
              return alreadyIn;
            }
          }
        }
      }
      return (this.insert(e));
    },

    allExcept : function(e, f, o) {
      if (typeof(f) === "string") {
        for (var i = this.all.length; i--; ) {
          if (this.all[i] !== e) {
            this.all[i][f](o);
          }
        }
      }
    },

    /**
     * Interface
     */

    sync : function() {

    },

    fixState : function() { // this takes all the pending client operations and merges them into one object
      this.saveState();
      var tmp = this.stashes[--this.cursor], i, j, stash;
      for (i = this.cursor; i--; ) {
        stash = this.stashes[i];
        for(j in stash) {
          if (stash.hasOwnProperty(j)) {
            if (tmp[j] && tmp[j].type !== 'remove') { // remove overrides all
              if (tmp[j].type === 'edit' && stash[j].type === 'edit') {
                tmp[j].input.smoothMerge(stash[j].input);
              }
              else { // edit && insert
                tmp[j].type = 'insert';
                tmp[j].input.smoothMerge(stash[j].input);
              }
            }
            else {
              tmp[j] = stash[j];
            }
          }
        }
      }
      for (i in tmp) {
        if (tmp.hasOwnProperty(i) && tmp[i].input) {
          tmp[i].input = this._toObject(tmp[i].input);
        }
      }

      this.cursor = 0;
      this.splice();
      this.backup = {};
      this.stash = {};

      return (tmp);
    },
    /**
     * Usage :
     * this.insert({ someRandom : "input" });
     * this.fixState() =>
     * { -1 : {
     *  type : "insert",
     *  input : { someRandom : "input" }
     * }
     */


    toStash : function(action) {

      //Need comment, PIE->Sam isn't it dangerous ?
      if (this._dp.digesting) return;

      //var inp = hardClone(action.model._raw);
      //if (action.type !== "insert") delete(inp.id);

      this.stash.push({
        type : action.type,
        input : action.input,//inp,//hardClone(action.input||action.model._raw), // care editId ...
        id : action.model.id
      });

    },

    /**
     * Versionning
     */

    previousState : function() {
      this._dp.digesting = true;
      var stash = this.antiStashes[--this.cursor];
      for (var i in stash) {
        if (stash.hasOwnProperty(i)) {
          this[stash[i].type](stash[i].input,i);
        }
      }
      this._dp.digesting = false;
    },

    nextState : function() {
      this._dp.digesting = true;
      var stash = this.stashes[this.cursor];
      for (var i in stash) {
        if (stash.hasOwnProperty(i)) {
          this[stash[i].type](stash[i].input,i);
        }
      }
      this._dp.digesting = false;
      this.cursor++;
    },

    saveState : function() {
      //--- We build the antiStash
      var antiStash = {}, action;
      for (var i in this.stash) {
        if (this.stash.hasOwnProperty(i)) {
          action = this.stash[i];
          if (action.type === 'edit') {
            antiStash[i] = {type:'edit',id:i,input:this.backup[i]};
          }
          else if (action.type === 'insert') {
            antiStash[i] = {type:'remove',id:i};
          }
          else if (action.type === 'remove') {
            antiStash[i] = {type:'insert',input:this.backup[i]};
          }
        }
      }
      this.antiStashes[this.cursor] = antiStash;

      this.backups[this.cursor] = this.backup;
      this.stashes[this.cursor] = this.stash;
      this.stash = {};
      this.backup = {};

      this.cursor++;
    },

    rollback : function() {
      this.saveState();
      for (var i = this.cursor; i--; ) {
        this.previousState();
      }
      this.fixState(); // clears this
    },

    //---
    // Merges 2 actions
    // NOTE :
    //  insert + edit =>
    //    stash : insert augmented with edit input
    //    backup : void
    //  edit + edit =>
    //    stash : edit augmented with edit input
    //    backup : i in input, if !backup[i], clone model[i]
    //  edit + remove => remove
    //    stash : remove
    //    backup : i in input, if !backup[i], clone model[i]
    //  insert + remove => remove
    //    stash : void
    //    backup : void
    //
    //
    // NOTE : there are still bugs with this atm, TODO : debug ...
    //-
    mergeActions : function(a1, a2) { // merges 2 actions
      if (a2.type === 'remove' && a1.inserted === true) {
        delete this.stash[a2.model.id];
        delete this.backup[a2.model.id];
      }
      else if (a2.type === 'remove') { // edit then remove
        a1.type = 'remove';

        this.smoothMergeClone(this.backup[a2.model.id],a2.model._raw);
        //this.backup[a2.model.id].smoothMergeClone(a2.model._raw);


        delete a1.input;
      }
      else if (a2.type === 'edit') {
        // insert + edit = insert
        this.mergeClone(a1.input, a2.input);
        if (a1.type === 'edit') // edit + edit {
          { this.smoothMergeClone(this.backup[a2.model.id], hardCloneProperties(a2.input, a2.model)); }
          //this.backup[a2.model.id].smoothMergeClone(a2.input);
        //else this.backup[a2.model.id] = (a2.input); // insert + edit
      }
    },

    mergeClone : function(a, b) {
      for (var i in b) {
        if (b.hasOwnProperty(i)) {
          a[i] = b[i];
        }
      }
    },

    smoothMergeClone : function(a, b) {
      for (var i in b) {
        if (b.hasOwnProperty(i)) {
          if (typeof(a[i]) === "undefined") {
            a[i] = hardClone(b[i]);
          }
        }
      }
    },

    /**
     * Basics
     */

    _instanciate : function(rawIndex, opt) {
      this.all.push(this._instances[this._raw[rawIndex].id] = new ((opt && opt.model && Store[opt.model]) || this._model)({ dp : this._dp, raw : this._raw[rawIndex], app : this._a, collection : this }));
      //this._instances[this._raw[rawIndex][0]].associate({ collection : this, assos : this.assos});
      return (this._instances[this._raw[rawIndex].id]);
    },

    generateId : function() { // generates a new id, not already used (by this collection) and < 0
      return this._dp.namespace + --this._minId;
    },

    insertMany : function(o, opt) {
      var mdls = [];
      for (var i = o.length; i--; ) mdls.push(this.insert(o[i], {dontFire:true}));
      this.fire("insert", mdls, opt);
      return mdls;
    },

    insert : function(o, opt) { // inserts a new model in this collection, and instanciates it
      //console.log(">>>> insert", o);


      if (!o.id) // no id
        o.id = this.generateId();

      if (!opt || !opt.dontFormat) {
        o = this._format(o);
      }
      //o = hardClone(o);

      this._instanciate(this._raw.push(o) - 1, opt);
      (!opt || !opt.dontPushStash) && this.toStash({type:'insert',model:this._instances[o.id],input:o}); //MCB, this was right before the nxt line
      this._instances[o.id].associate({ assos : this.assos, collection : this });
      (!opt || !opt.dontFire) && this.fire("insert", [this._instances[o.id]], opt); // models, opts
      return (this._instances[o.id]);
    },

    //WCB pas de dontPushStash pour insert, dnow
    edit : function(input, m, opt) { // fromRemove is used to not fire when its edit keys of a removed item
      //console.log(">>>> edit", m, input);



      var assos = [];
      for (var i in input) {
        if (input.hasOwnProperty(i))
          if (this._isKey[i]) {
            assos.push(i);
          }
      }

      var models = this._toMdls(m), j, resets = [], asso;
      for (i = models.length; i--; ) {

        if (!models[i]) {
          d.e&&console.log("[ERROR] edition of a non existing model, reinsert",models,i,m);
          this.insert(input);
        }

        else {

        var o = this._format(input, models[i]); // dot adding

        //hardfix -27000
        if (o['tm.rect']) {
          var fail = false;

          if (o['tm.rect'][0][1] < -1000000 || o['tm.rect'][0][1] > 1000000) {
            o['tm.rect'] = [[0, 0], o['tm.rect'][1]];
            fail = true;
          }

          if (o['tm.rect'][1][1] > 1000000) {
            o['tm.rect'] = [o['tm.rect'][0], [models[i].tm.rect[1][0], models[i].tm.rect[1][1]]];
            fail = true;
          }

          if (fail) {
            //console.log('fail', this._a.dp.logs.map(function(e) { return { type : e.type, name : e.name, input : e.input } }));
            $.ajax({
              type : 'POST',
              url : '/api/track/bug',
              data : {
                bug_id : '-27000',
                actions : JSON.stringify(this._a.dp.logs.map(function(e) { return { type : e.type, name : e.name, input : e.input } }))
              }
            });
          }
        }

        if (!models[i].removed) {


          models[i]._edit(o, opt); // this will fire onKeyChange and update associations if needed

          //MCB, it used to be above the previous line
          this.toStash({type:'edit',input:o,model:models[i]});

          for (j = assos.length; j--; ) {
            asso = models[i]["$"+this._isKey[assos[j]].label];
            if (typeof(opt) === "undefined" || typeof(opt.weak) === "undefined") {
              resets = resets.concat(asso.els.collect(function(e) { return e&&e["$"+asso._mirrorLabel] }));
            }
            if (typeof(opt) === "undefined" || typeof(opt.important) === "undefined") asso.onKeyChange();
            if (typeof(opt) === "undefined" || typeof(opt.weak) === "undefined") {
              resets = resets.concat(asso.els.collect(function(e) { return e&&e["$"+asso._mirrorLabel] }));
            }
          }
        }

        }
      }

      resets = resets.uniq();
      for (i = resets.length; i--; ) resets[i]&&resets[i].reset();

      (!opt || !opt.dontFire) && this.fire("edit", models, o, opt, input); // models, changes, options
      return [models, o, opt, input];
    },

    remove : function(o, oo) {


      //console.log(">>>> remove", o);
      o = this._toMdls(o);
      var resets = [];
      for (var i = o.length; i--; ) {

        if (!o[i]) {
          console.log("!!!!!! remove of an non existin model, doing nothing");
        }
        else {

        if (!oo || !oo.dontPushStash) this.toStash({type:'remove',id:o[i].id,model:o[i]});

        for (var j = o[i]._assos.length; j--; ) {
          for (var k = o[i]._assos[j].els.length; k--; ) {
            o[i]._assos[j].els[k] && resets.push(o[i]._assos[j].els[k]["$"+o[i]._assos[j]._mirrorLabel])
          }
        }

        this.all.remove(o[i]);
        this._raw.remove(o[i]._raw);
        this._instances[o[i].id] = null;

        o[i]._remove();

        }
      }

      // at this point, resets contains all the assos that needs to remove o (o might be not included in asso elements)
      resets = resets.uniq().exceptFn(function(e) {
        return e.removed
      });


      for (i = resets.length; i--; ) {
        if (resets[i].foreign) {
          resets[i].remove(o, {weak:true});
        }
        else {
          resets[i].remove(o, {weak:true});
        }
      }

      this.fire("remove", o, oo); // models, options
    },

    //---
    // Usage :
    // this.find({ label : "text" });
    // this.find(function(e) { return e.label === "text" });
    //
    // IMPORTANT NOTE : this.find(1) === this.find(1)
    //-
    find : function(o) { // either an id (string or number), a function, or an object
      if (typeof(o) === "number" || typeof(o) === "string") {
        return this._instances[o] || null; // we return the model if it has already been instanciated, otherwise we try to find it
      }
      var f = this._toF(o), res = [];
      for (var i = this.all.length; i--; ){
        if (f(this.all[i])) res.push(this.all[i]);
      }
      return res;
    },

    last : function(o) { // like find, but only returns the first found occurence, so it's faster'
      var f = this._toF(o); // we get the find function
      for (var i = this.all.length; i--; ) {
        if (f(this.all[i])) {
          return (this.all[i]);
        }
      } return null;
    },

    /**
     * Formats the input to allow dot notation
     */

    _format : function(o, m) {
      var format = function(o, r, prefix) {
        if (!r) r = {};
        if (!prefix) prefix = '';
        for (var i in o) if (o.hasOwnProperty(i)) {
          if (
            o[i] && // not null
            typeof(o[i]) === 'object' &&
            !isArray(o[i])) {
            format(o[i], r, prefix + i + '.');
          }
          else {
            r[prefix + i] = o[i];
          }
        }
        return r;
      }
      return format(o);

      var r = {};
      for (var i in o) {
        if (o.hasOwnProperty(i)) {
          var sp = i.split(".");
          if (sp.length > 1) { // dot
            r[sp[0]] = hardClone(m[sp[0]])||{};
            var a = r[sp[0]];
            for (var j = 1, n = sp.length - 1; j < n; j++) {
              a = a[sp[j]]||(a[sp[j]]={});
            }

            a[sp[n]] = o[i];
          }
          else {
            r[i] = o[i];
          }
        }
      }
      return r;
    },

    splice : function() {
      this.stashes.splice(this.cursor, this.stashes.length - this.cursor);
      this.backups.splice(this.cursor, this.backups.length - this.cursor);
      this.antiStashes.splice(this.cursor, this.antiStashes.length - this.cursor);
    },

    /**
     * Input formating helpers
     */

    _toObject : function(raw) {
      if (isArray(raw)) {
        var o = {};
        for (var i = raw.length; i--; ) if (typeof(raw[i]) !== 'undefined') o[this._attrs[i]] = raw[i];
        return o;
      }
      return (raw);
    },

    _toArray : function(raw) {
      if (!isArray(raw)) { // object
        var arrayedRaw = [];
        for (var i in raw) {
          if (raw.hasOwnProperty(i)) {
            arrayedRaw[this._toAttrs[i]] = raw[i];
          }
        }
        raw = arrayedRaw;
      }
      return raw;
    },

    _toMdls : function(o) {
      var r;
      if (!isArray(o)) { // not array
        if (typeof(o) === "number" || typeof(o) === "string") // id
          return ([this.find(o)]);
        // else model
          return ([o]);
      }
      if (r = o.length) { // array not empty
        if (typeof(o[0]) === "number" || typeof(o[0]) === "string") { // array of ids
          var r = [];
          for (var i = o.length; i--; ) r.push(this.find(o[i]));
          return r;
        }
        // else models
          return o.slice();
      }
      return [];
    },

    _toF : function(o) {
      if (typeof(o) === "function") return (o);
      var self = this
      if (typeof(o) === "object") return (function(elt) {
        for (var i in o) {
          if (o.hasOwnProperty(i) && elt[i] !== o[i]) return false;
        }
        return true;
      });
      if (typeof(o) === "undefined") return (function() {return true});
    }

  });

  Collection.extend = function(o) {
    if (!o.name) {
      //todo ?
      o.name = "missings";
    }
    return (Store[o.name.capitalize()] = r.Seed.extend.call(Collection, o));
  };

  for (var i in Array.prototype) {
    if (Array.prototype.hasOwnProperty(i) && !Collection.prototype[i]) {
      Collection.prototype[i] = (function(i) { return function() {
        return Array.prototype[i].apply(this.all, arguments);
      } })(i);
    }
  }

  Collection.prototype.map = function() {
    return Array.prototype.map.apply(this.all, arguments);
  };

  return Collection;

}));
(sand.define("DataPackage/Controller", [
    "Seed",
    "core/extend",
    "core/isArray",
    "core/empty",
    "DataPackage/Store",
    "DataPackage/Model",
    "DataPackage/Collection"
  ],
  function(r) {

  var extend = r.extend,
    isArray = r.isArray,
    empty = r.empty,
    Store = r.Store,
    d = this.debug;

  var Main = r.Seed.extend({

    '+init' : function(o) {
      this.logs = [];

      // get a random namespace string in hexa
      this.namespace = Math.random().toString(36).slice(2);
      this.timestamp = o.timestamp;
      this.diff = {};
      this.collections = {};
      this._ready = false;
      this._waiting = [];
      this.buffer = [];
      if (o.data) {
        this.doImport(o.data);
        this.ready();
      }
    },

    cache : function() {
      for (var i in this.collections) {
        if (this.collections.hasOwnProperty(i)) {
          for (var j = this.collections[i].all.length; j--; ) {
            if (this.collections[i].all[j].cache) this.collections[i].all[j].cache();
            else break;
          }
        }
      }
    },

    doImport : function(o) {
      this.collections = this.collections || {};
      for (var i in o) if (o.hasOwnProperty(i)) {
        var name =  i.capitalize().substr(0, i.length - 1);
        this.collections[i] = this.buildCollection({
          builder : Store[i.capitalize()],
          model : Store[name] || this.makeModel({ name : name }),//(app.Models && app.Models[i.capitalize().singularize()]) || this.makeModel({ name : i.capitalize().substr(0, i.length - 1) }),
          raw : o[i],
          app : this._a
        });
        this.diff[i] = this.collections[i].stash;
      }
    },

    saveState : function() {
      for (var i in this.collections) if (this.collections.hasOwnProperty(i)) this.collections[i].saveState();
    },

    nextState : function() {
      for (var i in this.collections) if (this.collections.hasOwnProperty(i)) this.collections[i].nextState();
    },

    previousState : function() {
      for (var i in this.collections) if (this.collections.hasOwnProperty(i)) this.collections[i].previousState();
    },

    notChanged : function() { // returns true if the dp hasn't changed locally, used before unload atm
      for (var i in this.collections) {
        if (this.collections[i].cursor) return false;
        if (!empty(this.collections[i].stash)) return false;
      }
      return true;
    },

    /*diff : function() { // gets all the changes for each collections, see DP.Collection.fixState
      var diff = {};
      for (var i in this.collections) diff[i] = this.collections[i].fixState();

      this._lastdiff = diff;
      return diff;
    },*/

    //---
    // Really important function, bit complex also
    //
    // It takes all the changes of all the collections and puts them in a array of requests, formated so that a model requiring the
    // existence of another is put before the other
    // NOTE : Each request is then independent
    // NOTE : As a convention, a model that has a foreign key with a < 0 value is considered requiring the pointed model
    //  as another convention, someRandomKey_id, someRandomKey_ids are foreign keys
    //
    // EXAMPLE :
    // a insert { model : "Post", input : { text : "someText", "author_id" : -1 } }
    // will be considered requiring a { type : "insert", model : "Author", input : { id : -1 ... } }
    // so the formated request of {model:"Post",type:"insert",input:{"text":"someText",author_id:-1}}, {model:"Author",type:"insert",input:{id:-1}}
    // will look like : [[[{model:"Author",type:"insert",input:{id:-1}}, {model:"Post",type:"insert",input:{"text":"someText",author_id:-1}}]]]
    //
    // the return is an array of requests
    // a request is an array of level
    // the lvl 0 is the one that depends on no other action
    // lvl 1 depends on lvl 0, ...
    // so, it looks like
    // [ // array of requests
    //   [ // first request
    //     [ // first lvl
    //       {} // first action
    //     ],
    //     [ // second lvl
    //       {} // action requering the first action
    //     ]
    //   ], // end of request
    //   [ // second request, no action of this is dependend of the first one
    //     [
    //       {}
    //     ]
    //   ] // end of second request
    // ] // end of requests
    //-
    format : function(diff) {
      var coll,
        res = [],
        keys,
        j,
        placed = {},
        requests = {},
        count = -1,
        collections = this.collections,
        dp = this,

        getNumber = function(request) {
          if (typeof(requests[request]) !== "number") {
            return request;
          }
          return getNumber(requests[request]);
        },

        getRequest = function(request) {
            if (typeof(request) === "number") return (getRequest(requests[request]));
            return request
        },

        unite = function(reqs) {
          var res = [], ns = [], i, num;
          for (i = reqs.length; i--; ) {
            num = getNumber(reqs[i]);
            if (!ns.has(num)) {
              ns.push(num);
              res.push(reqs[i]);
            }
          }
          return res;
        },

        merge = function(reqs) {
          reqs = unite(reqs);
          var n = reqs.length, req;
          if (n > 1)
          {
              requests[++count] = []; // new request

              for ( ; n--; ) // for each request to merge
              {
                  req = getRequest(requests[reqs[n]]); // we get the request (reqs is an array of pointers)
                  for (var i = 0, l = req.length; i < l; i++) // for each lvl (l) of the request
                  {
                     requests[count][i] = (requests[count][i] || []).concat(req[i]) // we add it to our new request lvl
                     //requests[count][i] = ; // we stack each request of each lvl
                  }
                requests[reqs[n]] = count; // we point to the new request
              }
              return (count);
          }
          else {
            var c = getNumber(reqs[0]);
            return (c)
          }
      },

      getKeys = function(o, coll) {
        var res = {};
        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            if (o[i] && typeof(o[i]) === "object" && !isArray(o[i])) {
              extend(res, getKeys(o[i], coll));
            }
            else {
              if (i.search(/_id/) !== -1 || i.search(/_ids/) !== -1) {
                var collName = getCollName(i, coll);
                res[collName] = o[i];
              }
            }
          }
        }
        return res;
      },

      getCollName = function(i, coll) {
        if (collections[coll]._isKey[i]) return collections[coll]._isKey[i].collection.name;
        else {
          // tm.parent_id
          var sp = i.split("_");
          sp.splice(sp.length-1,1);
          sp = sp.join("_");

          // tm.parent
          sp = sp.split(".");
          return (sp.last()+"s")
        }
      },

      place = function(coll, id) {
        var toMerge, lvl = -1, collName, p, o = diff[coll][id];
        //console.log("placing ---> "+coll+id);
        if (!placed[coll+id]) { // this operation is not already in a request
          if (o.input) { // && (keys = o.input.keys)) // we must check if there is a - id, otherwise we can put the operation in a new request (lvl 0)
            var keys = getKeys(o.input, coll);
            toMerge = [];
            for (var i in keys) if (keys.hasOwnProperty(i)) {
              collName = i;
              //console.log(keys);
              // we get the collection from the key name, so we can find the needed operation
              if (keys[i] && isArray(keys[i])) { // array of ids
                j = keys[i].length;
                for ( ; j--; ) {
                  if (diff[collName] && diff[collName][keys[i][j]]) { // local model
                    p = place(collName, keys[i][j]);
                    toMerge.push(p.request);
                    if (p.lvl > lvl) lvl = p.lvl; // we store the maximum lvl
                  }
                }
              }
              else if (diff[collName] && diff[collName][keys[i]]) {
                p = place(collName, keys[i]);
                toMerge.push(p.request);
                if (p.lvl > lvl) lvl = p.lvl;
              }
            }
          }

          o.model = collections[coll]._model.prototype.name;
          o.id = id;

          if (!++lvl) { // new request (lvl = 0)
            requests[++count] = [[o]]; // new request
            placed[coll+id] = {
              request : count,
              lvl : lvl
            }
          }
          else {
            j = merge(toMerge.uniq());

            (requests[j][lvl] || (requests[j][lvl] = [])).push(o);
            placed[coll+id] = {
              request : j, // this will build the new request
              lvl : lvl
            }
          }
        }
        return (placed[coll+id]);
      }

      for (var i in diff) {
        for (j in diff[i]) {
          place(i, j);
        }
      }

      var res = [];
      for (var i in requests) {
        if (requests.hasOwnProperty(i)) {
          (typeof(requests[i]) !== "number") && res.push(requests[i]);
        }
      }

      this._lastres = res;
      return res;
    },

    makeModel : function(o){
      return (this[o.name] = r.Model.extend(o));
    },

    buildCollection : function(o) { // [{}, {}] ...
      var collName = o.model.prototype.lowerName+"s";
      return (this.collections[collName] = this[collName] = new (this.getBuilder(o))(extend(o, { dp : this })));
    },

    getBuilder: function(o){
      // problem here cause "DP-Collection" requires DP ...
      return (o.builder || r.Collection.extend(o))
    },

    whenReady : function(c) {
      if (this._ready !== false) {
        c();
      }
      else {
        this._waiting.push(c);
      }
    },

    make : function(o) {
      for (var i = o.length; i--; ) {
        this.makeModel({
          name : o[i][0],
          attrs : o[i][1],
          associations : o[i][2]
        });
        this.buildCollection({
          model : this[o[i][0]],
          raw : o[i][3]
        });
      }
      this.ready();
    },

    ready : function() {
      for (var i = this._waiting.length; i--; ) {
        this._waiting[i]();
      }
      this._waiting = [];
    },

    dump : function() {
      var res = {}
      for (var i in this.collections) {
        if (this.collections.hasOwnProperty(i)) {
          var coll = this.collections[i];
          res[coll.name] = []
          coll.all.each(function(e) {
            // res[coll.name].push(e._raw)
            // fix (bug on editId)
            var o = {};
            for (var i in e._raw) {
              if (e._raw.hasOwnProperty(i)) {
                o[i] = e.get(i);
              }
            }
            res[coll.name].push(o);

          });
        }
      }
      return res;
    },

    mergeClone : function(a, b) {
      for (var i in b) {
        if (b.hasOwnProperty(i)) {
          a[i] = b[i];
        }
      }
    },

    smoothMergeClone : function(a, b) {
      for (var i in b) {
        if (b.hasOwnProperty(i)) {
          if (typeof(a[i]) === "undefined") {
            a[i] = hardClone(b[i]);
          }
        }
      }
    },

    format2 : function(diff) {
      String.prototype.singularize = function() { //dirty
        return this.substr(0, this.length-1);
      };

      var friendly = {},

        mergeClone = function(a, b) {
          for (var i in b) {
            if (b.hasOwnProperty(i)) {
              a[i] = b[i];
            }
          }
        };

      for (var i in diff) if (diff.hasOwnProperty(i)) {
        friendly[i] = this.merge(diff[i], i);
      }

      return (this.format(friendly));
    },

    merge : function(diff, collName) {
      var o = {},
        modelName = collName.capitalize().singularize();
      for (var i = 0, n = diff.length; i < n; i++) {
        var action = diff[i];
        action.model = modelName;

        if (action.type === "insert") {
          o[action.id] = action;
        }
        else if (action.type === "edit") {
          if (o[action.id]) { // insert + edit = insert
            this.mergeClone(o[action.id].input, action.input);
          }
          else { // nothing + edit = edit
            o[action.id] = action;
          }
        }
        else { // remove
          if (o[action.id] && o[action.id].type === "insert") delete(o[action.id]);
          else {
            o[action.id] = action;
          }
        }
      }
      return o;
    }

  });

  return Main;

}));
sand.define('DataPackage/Model', [
  'core/String/capitalize',
  'core/String/uncapitalize',
  'core/extend',
  'Seed',
  'DataPackage/Store',
  'DataPackage/BelongsToHO',
  'DataPackage/BelongsToMany',
  'DataPackage/HasManyBTM',
  'DataPackage/HasOne',
  'DataPackage/HasMany',
  'DataPackage/BelongsTo',
  'core/clone'
], function(r) {

  var extend = r.extend;

  return r.Seed.extend({

    uniqs : ['id'],

    '-init' : function(o) {
      this._a = o.app;
      this._dp = o.dp;
      this._raw = o.raw;
    },

    '+init' : function(o) {
      o = o.raw;
      var s, j, n, attr;
      for (var i in o) if (o.hasOwnProperty(i)) {
        s = i.split('.'), n = s.length;
        if (n > 1) {
          attr = this[s[0]]||(this[s[0]] = {});
          for (j = 1; j < n - 1; j++) {
            attr = attr[s[j]]||(attr[s[j]] = {});
          }
          attr[s[n - 1]] = o[i];
        }
        else {
          this._raw[i] = o[i];
          this[i] = o[i];
        }
      }
      return;
      for (var i in o.raw) {
        if (o.raw.hasOwnProperty(i)) {
          this[i] = o.raw[i];
        }
      }
    },

    associate : function(o) { // creates the associations of the model
      this._assos = [];
      for (var i in o.assos) {
        if (o.assos.hasOwnProperty(i)) {
          this._assos.push(this['$'+o.assos[i].label] = new (r[o.assos[i].constructor])(extend(o.assos[i], { owner : this, weak : o.weak })));
        }
      }
      if (o.collection) this._collection = o.collection;
    },

    get : function(path) { // gets a tree attribute, useful when you're not sure wheter the full tree exists or not
      var path = path.split('.'), ret = this;
      for (var i = 0, n = path.length; i < n; i++) {
        if (typeof((ret = ret[path[i]])) === 'undefined') return null;
        if (i < n - 1 && !ret) return null;
      }
      return ret;
    },

    set : function(path, value) { // sets a tree attribute, same as above
      var path = path.split('.'), ret = this;
      for (var i = 0, n = path.length-1; i < n; i++) {
        ret = ret[path[i]];
      }
      return (ret[path[n]] = value);
    },

    edit : function(o, opt) {
      this._collection.edit(o, this, opt);
    },

    _edit : function(o, opt) { // fires 'editId' if you edit the id, used by associations to update the keys
      var s, j, n, attr;
      for (var i in o) if (o.hasOwnProperty(i)) {
        s = i.split('.'), n = s.length;
        if (n > 1) {
          attr = this[s[0]]||((this[s[0]] = {}));
          for (j = 1; j < n - 1; j++) {
            attr = attr[s[j]]||(attr[s[j]] = {});
          }
          attr[s[n - 1]] = o[i];
          //this._raw[s[0]] = this[s[0]]; WCB ?
          this._raw[i] = o[i];
        }
        else {
          this._raw[i] = o[i];
          this[i] = o[i];
        }
      }
      this.fire('edit', o, opt);
    },

    _remove : function() {
      this.removed = true;
      this.fire('remove');
    },

    remove : function(o) {
      this._collection.remove(this, o);
    },

    extend : function(o) {
      var M = r.Seed.extend.call(this, o),
        ret = this.prototype._extend(o, M);
      if (o.name) {
        r.Store[o.name.capitalize()] = ret;
      }
      return ret;
    },

    _extend : function(o, M) {
      if (o.name) M.prototype.lowerName = o.name.uncapitalize();
      if (typeof(M.prototype.associations) === 'undefined') M.prototype.associations = [];

      return M;
    }

  });

});
(sand.define('DataPackage/Store', function() { return {} })); // auto-define of sand doesn't work when it's added on-the-fly to the module required

